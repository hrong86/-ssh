
##面试题
1. let、var和const的区别？
const 使用const声明的是常量，声明的变量只可以在声明时赋值，在后面出现的代码中不能再修改该常量的值，，
let方式声明的变量其作用域为该语句所在的代码块内，不存在变量提升，在声明之前调用会报错
let命令不存在变量提升
https://www.jianshu.com/p/0f49c88cf169   所谓暂时死区，就是不能在初始化之前，使用变量。 temporal dead zone

```
  var b = [];
  for (var i = 0; i < 10; i++) {
    b[i] = function () {
      alert(i);
    };
  }
  b[6]()

  var d = [];
  for (let j = 0; j < 10; j++) {
    d[j] = function () {
      alert(j);
    };
  }
  d[6]();
```

2. ES6新增的原始数据类型  Symbol

3. Antd栅格间隔可以使用Row的哪个属性  gutter

4. 
react父组件传给子组件的props变化时会调用子组件的哪个方法   componentWillReceiveProps

5. 
以下符合react对class的命名规范的是 MyTitle

6. react中加载数据这类ajax请求应该放在生命周期的什么方法里面？
componentDidMount

7. 箭头函数和匿名函数的理解
  箭头函数不可以使用arguments对象
  箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
  箭头函数不可以当作构造函数
  函数对象中的call、apply、bind三个方法，无法"覆盖"箭头函数中的this值
  箭头函数不属于普通的 function，所以没有独立的上下文

8. 关于react的生命周期的理解不正确的是？
A:
componentWillUnmount表示组件卸载前的状态

B:
componentWillReceiveProps 方法会在render之后执行

C:
componentDidMount 方法会在render方法之后执行

D:
componentWillMount 方法会在render方法之前执行
参考答案：	B


9. 
react中，只要是父组件的render被调用，在render中被渲染的子组件就会经历更新的过程。不管父组件传给子组件的props有没有改变，都会触发子组件的componentWillReceiveProps函数被调用，对吗？
参考答案：	不是

10.  componentWillUpdate这个生命周期不能立马设置setState，否则会出现循环调用 参考答案： 是

11. 以下哪项对apply、call和bind的理解不正确？

A:
apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表

B:
bind是返回了一个新的函数，并且立即执行

C:
三者都可以把一个函数应用到其他对象上

D:
call、apply是修改函数的作用域（修改this指向），并且立即执行
参考答案：	B

12. 箭头函数和匿名函数的理解不正确得是？

A:
箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

B:
箭头函数可以当作构造函数

C:
箭头函数不可以当作构造函数

D:
箭头函数不可以使用arguments对象
参考答案：	B

13. react中无状态函数组件不存在的特性是？

A:
组件不会被实例化

B:
组件可以访问生命周期的方法

C:
组件不能访问this对象

D:
组件无法访问生命周期的方法
参考答案：	B

14. 如果希望在react组件销毁时清理一些东西,例如回收定时器和取消代理时,要用到哪个方法

A:
componentWillReceiveProps

B:
componentDidUpdate

C:
componentDidMount

D:
componentWillUnMount
参考答案：	D


15. dva的8个概念中包含以下哪些

A:
Action

B:
dispatch

C:
State

D:
Reducer
参考答案：	A B C D

16. 以下哪些是ES6新增的数据结构

A:
WeakSet

B:
Map

C:
Set

D:
WeakMap
参考答案：	A B C D


17. componentDidUpdate() 组件更新后调用
是   不是
参考答案：	是

18. Antd中Form.create 包装的组件将会自带 this.props.form 属性
是   不是
参考答案：	是

19. 事件委托，目的，功能，写法
  把一个或者一组元素的事件委托到它的父层或者更外层元素上
  优点，减少内存消耗，动态绑定事件
  target 是触发事件的最具体的元素，currenttarget是绑定事件的元素(在函数中一般等于this)
  JavaScript 事件委托详解
  阻止事件冒泡 
  - event.stopPropagation();  则只阻止事件往上冒泡，不阻止事件本身
  - return false; 不仅阻止了事件往上冒泡，而且阻止了事件本身

  e.stopPropagation()的兼容写法（兼容IE）

  function stopPropagation(e) {  
      if (e.stopPropagation) {  
          e.stopPropagation();  
      } else {  
          window.event.cancelBubble = true;  
      }  
  }

20. 负载均衡

当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力
服务器集群负载均衡原理？

21. 什么是CDN缓存

CDN 是一种部署策略，根据不同的地区部署类似nginx 这种服务服务，会缓存静态资源。前端在项目优化的时候，习惯在讲台资源上加上一个 hash 值，每次更新的时候去改变这个 hash，hash 值变化的时候，服务会去重新取资源
(CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件
CDN_百度百科


22. javascript 中常见的内存泄露陷阱

内存泄露会导致一系列问题，比如：运行缓慢，崩溃，高延迟
内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来
意外的全局变量，这些都是不会被回收的变量（除非设置 null 或者被重新赋值），特别是那些用来临时存储大量信息的变量
周期函数一直在运行，处理函数并不会被回收，jq 在移除节点前都会，将事件监听移除
js 代码中有对 DOM 节点的引用，dom 节点被移除的时候，引用还维持
JavaScript 中 4 种常见的内存泄露陷阱

23. 网站性能优化

http 请求方面，减少请求数量，请求体积，对应的做法是，对项目资源进行压缩，控制项目资源的 dns 解析在2到4个域名，提取公告的样式，公共的组件，雪碧图，缓存资源，
压缩资源，提取公共资源压缩，提取 css ，js 公共方法
不要缩放图片，使用雪碧图，使用字体图表（阿里矢量图库）
使用 CDN，抛开无用的 cookie
减少重绘重排，CSS属性读写分离，最好不要用js 修改样式，dom 离线更新，渲染前指定图片的大小
js 代码层面的优化，减少对字符串的计算，合理使用闭包，首屏的js 资源加载放在最底部

24. js 自定义事件实现

原生提供了3个方法实现自定义事件
createEvent，设置事件类型，是 html 事件还是 鼠标事件
initEvent 初始化事件，事件名称，是否允许冒泡，是否阻止自定义事件
dispatchEvent 触发事件

25. get与post 通讯的区别

Get 请求能缓存，Post 不能
Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。
Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术
URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
Post 支持更多的编码类型且不对数据类型限制

26. 浅拷贝和深拷贝的问题

深拷贝和浅拷贝是只针对Object和Array这样的复杂类型的
也就是说a和b指向了同一块内存，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝
浅拷贝， ”Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象
深拷贝，JSON.parse()和JSON.stringify()给了我们一个基本的解决办法。但是函数不能被正确处理

27. 构造函数跟普通函数的区别
  构造函数：1. new fn( )
          2. 构造函数内部会创建一个新的对象，即f的实例
          3. 函数内部的this指向 新创建的f的实例
          4. 默认的返回值是f的实例
  普通函数：1. fn( )
          2. 在调用函数的内部不会创建新的对象
          3. 函数内部的this指向调用函数的对象（如果没有对象调用，默认是window）
          4. 返回值由return语句决定
  用instanceof 可以检查一个对象是否是一个类的实例，是则返回true


28. 原型跟原型链
  每个实例对象（object ）都有一个私有属性（称之为__proto__）指向它的原型对象（prototype）。该原型对象也有一个自己的原型对象(__proto__) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。

  function是对象，function的原型prototype也是对象，它们都会具有对象共有的特点。即：对象具有属性__proto__，每个对象都会在其内部初始化一个属性，就是__proto__，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去__proto__里找这个属性，这个__proto__又会有自己的__proto__，于是就这样一直找下去，也就是我们平时所说的原型链的概念。__proto__可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。

  所有对象都有__proto__属性，函数这个特殊对象除了具有__proto__属性，还有特有的原型属性prototype。prototype对象默认有两个属性，constructor属性和__proto__属性。prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而__proto__是查找某函数或对象的原型链方式。constructor，这个属性包含了一个指针，指回原构造函数

  原型链的继承
    当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

  someObject.[[Prototype]] 符号是用于指向 someObject的原型。
  从 ECMAScript 6 开始，[[Prototype]] 可以通过Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 __proto__。

  ![prototype](https://pic.xiaohuochai.site/blog/JS_ECMA_grammer_proto.png)
  上图中的复杂关系，实际上来源就两行代码
  ```
    function Foo(){};
    var f1 = new Foo;
  ```


  ```
    var f = function () {
      this.a = 1;
      this.b = 2;
    }

    var o = new f(); // {a: 1, b: 2}
    o.__proto__ === f.prototype; // true   `注意哈哈`
    o.constructor === f  //true
    o.prototype === f.prototype  //true;

    f.prototype.b = 3;
    f.prototype.c = 4;
    console.log(o.a)
  ```


  ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面
  ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。如果子类没有定义constructor方法，这个方法会被默认添加。

    大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。

  （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。

  （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。

  这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例

  29. vue修饰符
    v-on 
      .stop
      .prevent
      .capture
      .self
  ```
    <div id="app2">
      <!-- 阻止单击事件冒泡 -->
      <a v-on:click.stop="doThis"></a>
      <!-- 提交事件不再重载页面 -->
      <form v-on:submit.prevent="onSubmit"></form>
      <!-- 修饰符可以串联  -->
      <a v-on:click.stop.prevent="doThat"></a>
      <!-- 只有修饰符 -->
      <form v-on:submit.prevent></form>
      <!-- 添加事件侦听器时使用时间捕获模式 -->
      <div v-on:click.capture="doThis">...</div>
      <!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->
      <div v-on:click.self="doThat">...</div>
     </div>
  ```
  按键修饰符

    ```
    <!-- 只有在 keyCode 是 13 时调用 vm.submit() -->
    <input v-on:keyup.13="submit">
    <!-- 同上 -->
    <input v-on:keyup.enter="submit">
    <!-- 缩写语法 -->
    <input @keyup.enter="submit">
    ```

  全部的按键别名：

    enter
    tab
    delete (捕获 “删除” 和 “退格” 键)
    esc
    space
    up
    down
    left
    right

    可以通过全局 config.keyCodes 对象自定义按键修饰符别名：
    ```
      // 可以使用 v-on:keyup.f1
      Vue.config.keyCodes.f1 = 112

    lay：在改变后才触发（也就是说只有光标离开input输入框的时候值才会改变）
    <input v-model.lazy="msg" >
    number：将输出字符串转为Number类型·（虽然type类型定义了是number类型，但是如果输入字符串，输出的是string）
    <input v-model.number="age" type="number">
    trim：自动过滤用户输入的首尾空格
    <input v-model.lazy.trim="msg" >
  ```
  30. rem跟em的区别？rem布局原理是什么？rem有什么优势跟缺点？ 用户的设置字体将失效 ?通过什么方式把px转成rem? vw、vh是什么？跟rem有什么区别
  31. 两个自适应的元素如何高度一致
  32. 多行省略css
  33. 一个元素上下左右居中（自适应）
  34. 
    网页可见区域宽： document.body.clientWidth
    网页可见区域高： document.body.clientHeight
    网页可见区域宽： document.body.offsetWidth (包括边线的宽)
    网页可见区域高： document.body.offsetHeight (包括边线的高)
    网页正文全文宽： document.body.scrollWidth
    网页正文全文高： document.body.scrollHeight
    网页被卷去的高： document.body.scrollTop
    网页被卷去的左： document.body.scrollLeft
    网页正文部分上： window.screenTop
    网页正文部分左： window.screenLeft
    屏幕分辨率的高： window.screen.height
    屏幕分辨率的宽： window.screen.width
    屏幕可用工作区高度： window.screen.availHeight
    屏幕可用工作区宽度： window.screen.availWidth
